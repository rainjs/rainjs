{
  "name": "mocks",
  "description": "Set of mock modules for easy testing (fs, http)",
  "homepage": "",
  "keywords": [
    "mock",
    "stub",
    "dummy",
    "test double",
    "fake",
    "nodejs",
    "js",
    "testing",
    "test",
    "fs",
    "fs mock",
    "http",
    "http mock"
  ],
  "author": {
    "name": "Vojta JÃ­na",
    "email": "vojta.jina@gmail.com"
  },
  "contributors": [
    {
      "name": "Damien Duportal",
      "email": "damien.duportal@gmail.com"
    },
    {
      "name": "Taichi",
      "email": "ryushi@gmail.com"
    }
  ],
  "dependencies": {},
  "devDependencies": {
    "coffee-script": "1.1.2",
    "jasmine-node": "1.0.11",
    "jake": "0.2.15"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/vojtajina/node-mocks.git"
  },
  "main": "./lib/index",
  "bin": {},
  "engines": {
    "node": ">= 0.6.5"
  },
  "version": "0.0.10",
  "readme": "# Node Mocks [![Build Status](https://secure.travis-ci.org/vojtajina/node-mocks.png?branch=master)](http://travis-ci.org/vojtajina/node-mocks)\n\nSet of mocks and utilities for easier unit testing with [Node.js].\n\nSee http://howtonode.org/testing-private-state-and-mocking-deps for better explanation.\n\n## Prerequisites\n\n* [Node.js]\n* [NPM] (shipped with Node since 0.6.3)\n\n\n## Installation\n\n    sudo npm install -g mocks\n\n    # or install in local folder\n    npm install mocks\n\n\n## Example\n\n### Mocking a file system\n\n````javascript\n// during unit test - we inject mock file system instead of real fs\nvar fs = require('fs');\n\n// even if this function is not public, we can test it directly\nvar filterOnlyExistingFiles = function(collection, done) {\n  var filtered = [],\n      waiting = 0;\n\n  collection.forEach(function(file) {\n    waiting++;\n    fs.stat(file, function(err, stat) {\n      if (!err && stat.isFile()) filtered.push(file);\n      waiting--;\n      if (!waiting) done(null, filtered);\n    });\n  });\n};\n````\n\n````coffeescript\n# simple unit test (jasmine syntax, coffescript)\ndescribe 'app', ->\n  mocks = require 'mocks'\n  loadFile = mocks.loadFile\n  app = done = null\n\n  beforeEach ->\n    done = jasmine.createSpy 'done'\n    # load the file and inject fake fs module\n    app = loadFile __dirname + '/app.js',\n      fs: mocks.fs.create\n        'bin':\n          'run.sh': 1,\n          'install.sh': 1\n        'home':\n          'some.js': 1,\n          'another.txt': 1\n        'one.js': 1,\n        'two.js': 1,\n        'three.js': 1\n\n\n  it 'should return only existing files', ->\n    done.andCallFake (err, filtered) ->\n      expect(err).toBeFalsy()\n      expect(filtered).toEqual ['/bin/run.sh']\n\n    app.filterOnlyExistingFiles ['/bin/run.sh', '/non.txt'], done\n    waitsFor -> done.callCount\n\n  it 'should ignore directories', ->\n    done.andCallFake (err, filtered) ->\n      expect(filtered).toEqual ['/bin/run.sh', '/home/some.js']\n\n    app.filterOnlyExistingFiles ['/bin/run.sh', '/home', '/home/some.js'], done\n    waitsFor -> done.callCount\n````\n\n### Faking randomness\nNon-blocking I/O operations can return in random order. Let's say you read a content of two files (asynchronously). There is no guarantee, that you get the content in right order. That's fine, but we want to test our code, whether it can handle such a situation and still work properly. In that case, you can use `predictableNextTick`, which process callbacks depending on given pattern.\n\n````coffeescript\n\n  it 'should preserve order', ->\n    done.andCallFake (err, filtered) ->\n      expect(filtered).toEqual ['/one.js', '/two.js', '/three.js']\n\n    app.filterOnlyExistingFiles ['/one.js', '/two.js', '/three.js'], done\n    waitsFor -> done.callCount\n````\nThis test will always pass. That's cool, as we like to see tests passing. The bad thing is, that it does not work in production, with real file system, as it might return in different order...\nSo, we need to test, whether our app works even when the `fs` returns in random order. Having randomness in unit tests is not good habit, as it leads to flaky tests.\nLet's change the previous unit test to this:\n\n````coffeescript\n  it 'should preserve order', ->\n    done.andCallFake (err, filtered) ->\n      expect(filtered).toEqual ['/one.js', '/two.js', '/three.js']\n\n    mocks.predictableNextTick.pattern = [2, 0, 1]\n    app.filterOnlyExistingFiles ['/one.js', '/two.js', '/three.js'], done\n    waitsFor -> done.callCount\n````\nNow, the unit test fails, because our fake file system calls back in different order. Note, it's not random, as you explicitly specified the pattern (2, 0, 1), so it the fake fs will consistently call back in this order: /three.js, /one.js, two.js.\n\n\n## API\nCurrently supported API is only very small part of real [Node's API]. Basically I only implemented methods I need for testing [Testacular].\n\nI will keep adding more and of course if anyone wants to help - pull requests are more than welcomed.\n\n### [fs](http://nodejs.org/api/fs.html)\n\n- stat(path, callback)\n- readdir(path, callback)\n- readFile(path [, encoding], callback)\n- readFileSync(path)\n- watchFile(path [, options], callback)\n- _touchFile(path, mtime, content) *\n\n### [http](http://nodejs.org/api/http.html)\n\n- http.ServerResponse\n- http.ServerRequest\n\n### [glob](https://github.com/isaacs/node-glob)\n\n\n### loadFile(path [, mocks] [, globals])\n### predictableNextTick(fn)\n### predictableNextTick.pattern\n\n[Node.js]: http://nodejs.org/\n[NPM]: http://npmjs.org/\n[Node's API]: http://nodejs.org/docs/latest/api/index.html\n[Testacular]: https://github.com/vojtajina/testacular\n",
  "readmeFilename": "README.md",
  "_id": "mocks@0.0.10",
  "_from": "mocks@0.0.10"
}
